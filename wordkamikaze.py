# This is a Program for word autocomplete based on dictionary with prefix-based matching
import pynput
from pynput import keyboard
import tkinter as tk
import time
import random
from typing import Set, List

class WordAutocomplete:
    # Typing speed configuration (in seconds)
    BASE_CHAR_DELAY = 0.03  # base delay between characters
    CHAR_DELAY_VARIANCE = 0.03  # random variance in character delay
    WORD_DELAY = 0.15  # extra delay after completing a word
    # Probability of a slightly longer pause between characters (simulates natural typing rhythm)
    PAUSE_PROBABILITY = 0.2  # 20% chance of a micro-pause
    MICRO_PAUSE = 0.08  # length of micro-pause in seconds
    # Toggle shortcut keys
    TOGGLE_KEYS = {keyboard.Key.alt_l, keyboard.Key.ctrl_l, keyboard.KeyCode.from_char('t')}

    def __init__(self):
        # Load dictionary
        self.dictionary = self.load_dictionary('dict.txt')
        self.used_words: Set[str] = set()
        self.current_input = ""  # Store the raw input including the number
        self.suggestions: List[str] = []
        self.suggestion_index = 0
        # Track toggle shortcut keys
        self.current_keys = set()
        # Auto-completion state
        self.is_enabled = True
        # Controller to emit keystrokes (for auto-completion)
        self.controller = keyboard.Controller()
        # When True, ignore events generated by our own Controller
        self.suppress_listener = False
        # Count of characters typed since last automatic completion
        self.typed_since_last_completion = 0
        # After we auto-complete once, block immediate further auto-completes
        # until the user types again (this prevents chained completions)
        self.post_completion_block = False
        # Timestamp of last synthetic emission (seconds since epoch)
        self.last_emission_time = 0.0
        # Minimal grace period after emission during which we ignore incoming events
        # Start with a conservative base so synthetic typing isn't re-processed
        self.emission_grace_base = 0.2  # seconds

        self.root = tk.Tk()
        self.root.title("Word Autocomplete")
        
        # Make window stay on top
        self.root.attributes('-topmost', True)
        # Make window transparent
        self.root.attributes('-alpha', 0.8)
        # Remove window decorations
        self.root.overrideredirect(True)
        
        # Configure root window background
        self.root.configure(bg='white')
        
        # Create frame with padding and background
        frame = tk.Frame(self.root, bg='white', padx=10, pady=5)
        frame.pack(expand=False)
        
        # Create labels for current word and suggestion
        self.current_label = tk.Label(
            frame,
            text="Type: ",
            font=("Arial", 14),
            bg='white',
            fg='gray',
            padx=10,
            pady=5
        )
        self.current_label.pack(side=tk.LEFT)
        
        self.suggestion_label = tk.Label(
            frame,
            text="Suggestion: None",
            font=("Arial", 14),
            bg='white',
            fg='black',
            padx=10,
            pady=5
        )
        self.suggestion_label.pack(side=tk.LEFT)
        
        # Status label to show enabled/disabled state - acts as a clickable button
        self.status_label = tk.Label(
            frame,
            text="[Active]",
            font=("Arial", 12),
            bg='white',
            fg='green',
            padx=10,
            pady=5,
            cursor='hand2'  # Change cursor to hand when hovering
        )
        # Bind click event to toggle
        self.status_label.bind('<Button-1>', lambda e: self.toggle_active_state())
        self.status_label.pack(side=tk.LEFT)
        
        # Position window in top-center
        # Get screen width and window size to calculate center position
        self.root.update_idletasks()  # Update to get correct window size
        screen_width = self.root.winfo_screenwidth()
        window_width = self.root.winfo_width()
        x_position = (screen_width - window_width) // 2
        
        self.root.geometry('+{}+{}'.format(x_position, 20))
    
    def load_dictionary(self, filename: str) -> List[str]:
        try:
            with open(filename, 'r') as f:
                return [word.strip().lower() for word in f.readlines()]
        except FileNotFoundError:
            print(f"Warning: {filename} not found. Using empty dictionary.")
            return []
    
    def parse_input(self, input_str: str) -> tuple:
        """
        Parse the input string to extract the number and letters.
        Returns (num_letters, letters) or (None, None) if invalid.
        Examples:
            "2bl" -> (2, "bl")
            "3par" -> (3, "par") 
        """
        if not input_str:
            return None, None
        
        # Check if first character is a digit
        if input_str[0].isdigit():
            # Find how many digits are in the number
            num_str = ""
            i = 0
            while i < len(input_str) and input_str[i].isdigit():
                num_str += input_str[i]
                i += 1
            
            if num_str:
                num_letters = int(num_str)
                letters = input_str[i:]
                
                # Check if we have enough letters
                if len(letters) >= num_letters:
                    return num_letters, letters[:num_letters]
        
        return None, None
    
    def find_suggestions(self) -> List[str]:
        """
        Find word suggestions based on the prefix system.
        The first digit indicates how many letters to use for matching.
        """
        num_letters, prefix = self.parse_input(self.current_input)
        
        if num_letters is None or prefix is None:
            return []
        
        print(f"Looking for words starting with '{prefix}' (using {num_letters} letters)")
        
        # Find words that start with the given prefix
        matches = []
        for word in self.dictionary:
            word_lower = word.lower()
            if (word_lower.startswith(prefix) and
                word not in self.used_words and
                len(word) >= len(prefix)):  # Word should be longer than prefix
                matches.append(word)
        
        if not matches:
            print(f"No matches found for prefix '{prefix}'")
            return []

        # Sort matches by length (shorter first) and then alphabetically
        sorted_matches = sorted(matches, key=lambda x: (-len(x), x))
        # Take up to 5 suggestions
        suggestions = sorted_matches[:5]
        print(f"Top {len(suggestions)} suggestions:")
        for i, sugg in enumerate(suggestions, 1):
            print(f"  {i}. {sugg} (length: {len(sugg)})")
        return suggestions
    
    def update_display(self):
        # Update current input display
        self.current_label.config(text=f"Input: {self.current_input}")
        
        # Update suggestion
        if self.suggestions:
            suggestion = self.suggestions[self.suggestion_index]
            # Show the full suggestion
            self.suggestion_label.config(
                text=f"Suggestion: {suggestion}"
            )
        else:
            num_letters, prefix = self.parse_input(self.current_input)
            if num_letters is not None and prefix is not None:
                self.suggestion_label.config(text=f"Suggestion: None (prefix: '{prefix}')")
            else:
                self.suggestion_label.config(text="Suggestion: None")
        
        self.root.update()
    
    def toggle_active_state(self):
        """Toggle auto-completion on/off and update status display"""
        self.is_enabled = not self.is_enabled
        self.status_label.config(
            text="[Active]" if self.is_enabled else "[Inactive]",
            fg="green" if self.is_enabled else "red"
        )
        # Clear current input and suggestions when disabling
        if not self.is_enabled:
            self.current_input = ""
            self.suggestions = []
            self.update_display()
    
    def handle_key(self, key):
        # Handle toggle shortcut (Ctrl+Alt+T)
        if isinstance(key, keyboard.KeyCode):
            if key in self.TOGGLE_KEYS:
                self.current_keys.add(key)
            # Check if all toggle keys are pressed
            elif self.current_keys == self.TOGGLE_KEYS:
                self.toggle_active_state()
                return
        elif key in self.TOGGLE_KEYS:
            self.current_keys.add(key)
            # Check if all toggle keys are pressed
            if self.current_keys == self.TOGGLE_KEYS:
                self.toggle_active_state()
                return
        
        # If we're emitting keys ourselves, ignore them in the handler
        if self.suppress_listener:
            return
            
        # If auto-completion is disabled, only handle toggle keys
        if not self.is_enabled:
            return

        try:
            # Handle normal characters
            # If we're within a short window after our own emission, ignore events
            now = time.time()
            if now - self.last_emission_time < self.emission_grace_base:
                return

            if hasattr(key, 'char') and key.char:
                # append character
                ch = key.char
                self.current_input += ch
                
                # Parse the current input to see if we have a valid pattern
                num_letters, prefix = self.parse_input(self.current_input)
                
                if num_letters is not None and prefix is not None:
                    # We have a valid pattern, find suggestions
                    self.suggestions = self.find_suggestions()
                    self.suggestion_index = 0
                    
                    # Auto-complete when we have exactly the right number of letters
                    if len(prefix) == num_letters and self.suggestions:
                        # Use the first suggestion (shortest word)
                        suggestion = self.suggestions[0]
                        
                        # First clear our internal state
                        self.current_input = ""
                        self.suggestions = []
                        self.typed_since_last_completion = 0
                        
                        # Block any events for a short time after completion
                        self.suppress_listener = True
                        try:
                            # Backspace the entire input (number + letters)
                            input_length = len(str(num_letters)) + num_letters
                            for _ in range(input_length):
                                self.controller.press(keyboard.Key.backspace)
                                self.controller.release(keyboard.Key.backspace)
                                time.sleep(0.02)
                            
                            # Now type the full word with natural timing
                            for i, char in enumerate(suggestion):
                                self.controller.type(char)
                                
                                # Calculate random delay for this character
                                char_delay = self.BASE_CHAR_DELAY + random.uniform(0, self.CHAR_DELAY_VARIANCE)
                                
                                # Add micro-pauses occasionally
                                if random.random() < self.PAUSE_PROBABILITY:
                                    char_delay += self.MICRO_PAUSE
                                
                                # Extra delay before certain characters
                                if i < len(suggestion) - 1:
                                    next_char = suggestion[i + 1]
                                    if next_char.isupper() or next_char in ['.', ',', ';', ':', '?', '!']:
                                        char_delay += self.CHAR_DELAY_VARIANCE
                                
                                time.sleep(char_delay)
                            
                            self.used_words.add(suggestion)
                            
                            # Add a natural pause after completing the word
                            time.sleep(self.WORD_DELAY)
                            
                            # Record emission time and adjust grace period
                            self.last_emission_time = time.time()
                            # Increase grace proportional to word length for reliability
                            self.emission_grace_base = max(0.2, 0.08 * len(suggestion) + 0.15)
                        finally:
                            self.suppress_listener = False
                            
                        # Clear state again to be safe
                        self.current_input = ""
                        self.suggestions = []
                        # Block further auto-completes until the user types again
                        self.post_completion_block = True
                        return  # Exit the handler immediately

                # If we recently auto-completed, the first real user key resets the block
                if self.post_completion_block:
                    # Start counting from this character as the first after completion
                    self.post_completion_block = False
                    self.typed_since_last_completion = 1
                else:
                    # Increment typed-since-last-completion counter
                    self.typed_since_last_completion += 1

            # Handle special keys
            elif key == keyboard.Key.space or key == keyboard.Key.enter:
                # Complete word if there's a suggestion
                if self.suggestions:
                    self.used_words.add(self.suggestions[self.suggestion_index])
                self.current_input = ""
                self.suggestions = []
                # Reset typed counter and clear post-completion block when user finishes word
                self.typed_since_last_completion = 0
                self.post_completion_block = False

            elif key == keyboard.Key.backspace:
                if self.current_input:
                    self.current_input = self.current_input[:-1]
                    # Only find new suggestions if we still have a valid pattern
                    num_letters, prefix = self.parse_input(self.current_input)
                    if num_letters is not None and prefix is not None:
                        self.suggestions = self.find_suggestions()
                    else:
                        self.suggestions = []
                    self.suggestion_index = 0
                    # Adjust typed counter when the user backspaces
                    if self.typed_since_last_completion > 0:
                        self.typed_since_last_completion -= 1
                    # If user manually modifies the word, clear post-completion block
                    self.post_completion_block = False
            elif key == keyboard.Key.tab:
                # Cycle through suggestions
                if self.suggestions:
                    self.suggestion_index = (self.suggestion_index + 1) % len(self.suggestions)

            self.update_display()

        except AttributeError:
            pass  # Ignore other special keys

def on_press(key, autocomplete):
    autocomplete.handle_key(key)
    
def on_release(key, autocomplete):
    if key == keyboard.Key.esc:
        autocomplete.root.quit()
        return False
    # Remove released keys from the tracked set
    if key in autocomplete.TOGGLE_KEYS:
        try:
            autocomplete.current_keys.remove(key)
        except KeyError:
            pass  # Key wasn't in the set

def main():
    # Create the autocomplete window
    autocomplete = WordAutocomplete()
    
    # Create the keyboard listener
    listener = keyboard.Listener(
        on_press=lambda key: on_press(key, autocomplete),
        on_release=lambda key: on_release(key, autocomplete)
    )
    
    # Start the listener in a non-blocking way
    listener.start()
    
    # Run the GUI
    try:
        autocomplete.root.mainloop()
    except Exception as e:
        print(f"Error: {e}")
    finally:
        listener.stop()

if __name__ == "__main__":
    main()


